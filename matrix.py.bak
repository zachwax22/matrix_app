#type: ignore

class Matrix:
    
    def __init__(self, verbose: bool = False, ecl: int = 0, ecd: int = 4) -> None:
        '''
        Basic constructor, initializes an empty 2D matrix
        verbose: False to hide debug prints, True to show them
        ecl: int for error correction (for floating-point error):
          0 -> no error correction
          1 -> only at the end of operation
          2 -> after any given step
        '''
        self.m = [[]]
        self.verbose = verbose
        self.ecl = ecl
        self.ecd = ecd
        if(self.verbose):
            print("Initialized new blank matrix")

    def __getitem__(self, index: int) -> list:
        return self.m[index]

    def __setitem__(self, index: int, value: list) -> None:
        self.m[index] = value
        
    def __len__(self) -> int:
        return len(self.m)

    def __str__(self) -> str: 
        # Converts the matrix to a legible multi-line string representation
        string_matrix = []
        column_has_negative = []
        for i in range(len(self.m)): # Converts the matrix to a 2D array of strings - also tracks negatives
            string_matrix.append([])
            for j in range(len(self.m[i])):
                if(len(column_has_negative) <= j):
                    column_has_negative.append(False)
                self.m[i][j] = round(self.m[i][j], 5)
                if(round(self.m[i][j], 0) == self.m[i][j]): # Removes redundant '.0's
                    self.m[i][j] = int(self.m[i][j])
                if(self.m[i][j] < 0):
                    column_has_negative[j] = True
                string_matrix[i].append(str(self.m[i][j]))

        lengths_by_column = [] # Finds the maximum number length in each column
        for i in range(len(string_matrix[0])):
            column = []
            for j in range(len(string_matrix)):
                column.append(len(string_matrix[j][i]))
            lengths_by_column.append(max(column))

        for i in range(len(string_matrix)): # Iterates through each number in the string matrix and adjusts it to that each is height-aligned
            for j in range(len(string_matrix[i])):
                if(column_has_negative[j] and self.m[i][j] >= 0):
                    string_matrix[i][j] = ' ' + string_matrix[i][j]
                # i: row position, j: column position
                while(len(string_matrix[i][j]) < lengths_by_column[j]):
                    if('.' in string_matrix[i][j]):
                        string_matrix[i][j] += ' '
                    else:
                        string_matrix[i][j] = ' ' + string_matrix[i][j]
        
        result = ''
        for i in range(len(string_matrix)): # Reconstitutes string matrix into lines, then concatenates the lines
            row = ''
            for j in range(len(string_matrix[i])):
                row += string_matrix[i][j] + ' '
            if(i == len(string_matrix) - 1):
                result += row
            else:
                result += row + '\n'

        return result

    __repr__ = __str__

    def __add__(self, other: 'Matrix | float | int')-> 'Matrix | None':
        # Element-by-element addition - only exists for same-dimension matrix pairs (alternatively, element-by-element addition)
        if(type(other) == Matrix):
            if(len(self.m) == len(other.m) and len(self.m[0]) == len(other.m[0])):
                result = self._calloc(len(self.m), len(self.m[0]))
                for i in range(len(result.m)):
                    for j in range(len(result.m[0])):
                        result.m[i][j] = self.m[i][j] + other.m[i][j]
                return result
        elif(type(other) == float or type(other) == int):
            result = self._calloc(len(self.m), len(self.m[0]))
            for i in range(len(self.m)):
                for j in range(len(self.m[0])):
                    result.m[i][j] = self.m[i][j] + other
            return result
    
    def __sub__(self, other: 'Matrix | float | int') -> 'Matrix | None':
        # Same concept as addition, but rewriting is more efficient than doing it as M-N = M+(N*-1)
        if(type(other) == Matrix):
            if(len(self.m) == len(other.m) and len(self.m[0]) == len(other.m[0])):
                result = self._calloc(len(self.m), len(self.m[0]))
                for i in range(len(result.m)):
                    for j in range(len(result.m[0])):
                        result.m[i][j] = self.m[i][j] - other.m[i][j]
                return result
        elif(type(other) == float or type(other) == int):
            result = self._calloc(len(self.m), len(self.m[0]))
            for i in range(len(self.m)):
                for j in range(len(self.m[0])):
                    result.m[i][j] = self.m[i][j] - other
            return result
            
    def __mul__(self, other: 'Matrix | float | int')-> 'Matrix | None':
        # Matrix multiplication: other must have as many rows as self has columns
        # Alternatively, scalar multiplication - just element-by-element
        if(type(other) == float or type(other) == int):
            result = self._calloc(len(self.m), len(self.m[0]))
            for i in range(len(self.m)):
                for j in range(len(self.m[0])):
                    result.m[i][j] = self.m[i][j] * other
            return result
        elif(type(other) == Matrix):
            if(len(self.m[0]) == len(other.m)):
                # dot product case
                if(len(self.m) == len(other.m[0]) == 1):
                    result_num = 0.0
                    for i in range(len(self.m[0])):
                        result_num += self.m[0][i] * other.m[i][0]
                    # returns 1x1 matrix instead of float to follow convention
                    result = Matrix()
                    result.m = [[result_num]]
                    return result
                # matrix mult case
                else:
                    result = self._calloc(len(self.m), len(other.m[0]))
                    for i in range(len(result.m)):
                        for j in range(len(result.m[0])):
                            # Create two sub-matrices (a row and a column, respectively) to create a dot product
                            A_vec = self.row(i)
                            B_vec = other.column(j)
                            element = A_vec * B_vec # calls the dot product case
                            result.m[i][j] = element.m[0][0]
                    return result
                
    def __pow__(self, power: int) -> 'Matrix | None':
        # Exponentiation for square matrices (non-integers not supported due to yielding complex results)
        if(type(power) == int and self.is_square):
            if(power < 0):
                power = abs(power)
                result = self ** power
                return result.inverse()
            elif(power == 0):
                return self.identity(len(self.m))
            else:
                result = self.duplicate()
                while(power > 1):
                    result *= self
                    power -= 1
                return result

    def __abs__(self) -> 'Matrix':
        result = self._calloc(len(self.m), len(self.m[0]))
        for i in range(len(self.m)):
            for j in range(len(self.m[0])):
                result.m[i][j] = abs(self.m[i][j])
        return result
    
    def __neg__(self) -> 'Matrix':
        result = self._calloc(len(self.m), len(self.m[0]))
        for i in range(len(self.m)):
            for j in range(len(self.m[0])):
                result.m[i][j] = -self.m[i][j]
        return result

    def __eq__(self, other: 'Matrix | int | float') -> bool:
        # Determines equivalency based on the contents of each matrix
        if(type(other) == Matrix):
            return self.m == other.m
        elif((type(other) == float or type(other) == int) and len(self.m) == len(self.m[0]) == 1):
            return self.m[0][0] == other
        else:
            return False

    def row(self, row: int) -> 'Matrix | None':
        # returns a Matrix object with just a given row (ZERO-INDEXED)
        if(row < len(self.m)):
            result = Matrix()
            result.m[0] =  self.m[row]
            return result

    def column(self, col: int) -> 'Matrix | None':
        # returns a Matrix object with just a given column (ZERO-INDEXED)
        if(col < len(self.m[0])):
            result = Matrix()
            result.m = []
            for i in range(len(self.m)):
                result.m.append([self.m[i][col]])
            return result
        
    def _slice_rows(self, start: int, end: int):
        result = self._calloc(end - start, len(self.m[0]))
        result.m = []
        while(start < end):
            result.m.append(self.m[start])
            start += 1
        return result

    def _slice_columns(self, start: int, end: int):
        end
        result = self._calloc(len(self.m), end - start)
        result.m = []
        for i in range(len(self.m)):
            result.m.append(self.m[i][start:end])
        return result

    def _slice_parse(self, txt: str) -> tuple:
        if(txt == '' or txt == ':'):
            start = 0
            end = len(self.m)
        elif(':' not in txt and txt.isnumeric()):
            start = int(txt)
            end = int(txt)
        else:
            (start, end) = txt.split(':')
            (start, end) = (int(start), int(end))
        return (start, end)

    def slice(self, rows: str, cols: str) -> 'Matrix':
        '''Slices a matrix to include only a given row/column range.
        Follows python syntax.
        To include all rows or columns, make that argument either ':' or ''
        '''
        (row_start, row_end) = self._slice_parse(rows)
        (col_start, col_end) = self._slice_parse(cols)
        result = self._slice_rows(row_start, row_end)
        result = result._slice_columns(col_start, col_end)
        return result
        
    def concat(self, other: 'Matrix') -> 'Matrix':
        # Concatenates two matrices side-by-side
        if(type(other) == Matrix and len(self.m) == len(other.m)):
            result = self.duplicate()
            for i in range(len(self.m)):
                result.m[i] += other.m[i]
            return result
    
    def dot(self, other: 'Matrix') -> float | None:
        # Takes the dot product of two one-column vectors
        if(type(other) == Matrix):
            if(len(self.m[0]) == len(other.m[0]) == 1):
                result = 0
                for i in range(len(self.m)):
                    result += self.m[i][0] * other.m[i][0]
                return result

    def import_string(self, matrix: str) -> None:
        # Parses user input to create the self.m matrix
        # Accepts MATLAB notation, e.g. [1 2 3; 4.0 -5 6.7; 7 8 9]
        if(matrix[0] != '['):
            print("Parsing error")
        else:
            if(matrix[-1] != ']'):
                matrix = matrix[1:matrix.index(']')]
            else:
                matrix = matrix[1:-1] # strips brackets
            rows = matrix.split(';') # splits into rows separated by semicolons
            for i in range(len(rows)):
                rows[i] = rows[i].strip()
                rows[i] = rows[i].split(' ') # splits into numbers separated by whitespace - now a 2d array
                j = 0
                while(j < len(rows[i])):
                    if(rows[i][j] == ''): # if an empty space is given (from extra whitespace), remove it and adjust array accordingly
                        del rows[i][j]
                        j -= 1
                    else:
                        rows[i][j] = float(rows[i][j])
                    j += 1
            self.m = rows
            if(self.verbose):
                print("String successfully imported as:")
                print(self)

    def _calloc(self, rows: int, cols: int = -1) -> 'Matrix':
        # Creates an list matrix of zeroes...([[0.0]*n]*m) doesn't work because it creates duplicates
        if(cols < 0): # square case
            cols = rows
        matrix = Matrix()
        matrix.m = []
        for i in range(rows):
            matrix.m.append([0.0] * cols)
        return matrix
    
    def identity(self, rows: int, cols: int = -1) -> 'Matrix':
        # Creates an identity matrix (e.g. [1 0 0; 0 1 0; 0 0 1]) of a given size
        if(cols < 0): # square case
            cols = rows
        matrix = self._calloc(rows, cols)
        i = 0
        while(i < len(matrix.m) and i < len(matrix.m[0])):
            matrix.m[i][i] = 1.0
            i += 1
        return matrix

    def _find_decomposed(self, working_col: int) -> 'Matrix':
        # Finds the decomposition of a given matrix, used for determinant algorithm
        decomp = self._calloc(len(self.m) - 1)
        i = 0
        decomp_col = 0
        while(i < len(self.m)):
            if(i == working_col):
                i += 1
            if(i < len(self.m)):
                for j in range(1, len(self.m)):
                    decomp.m[j-1][decomp_col] = self.m[j][i]
                decomp_col += 1
            i += 1
        if(self.verbose):
            print(f"Decomposition matrix #{working_col}:")
            print(decomp)
        return decomp

    def determinant(self) -> float | None:
        # Computes determinant via decomposition
        length = len(self.m)
        if(length != len(self.m[0]) or length == 0 or self.is_jagged):
            result = None
            if(self.verbose):
                print("Given an uneven, jagged or empty matrix - returning None")
        elif(length == 1):
            result = self.m[0][0]
            if(self.verbose):
                print(f"1x1 matrix - returning {result}")
        elif(length == 2):
            result = self.m[0][0] * self.m[1][1] - self.m[0][1] * self.m[1][0]
            if(self.verbose):
                print(f"2x2 matrix - returning {result}")
        else:
            result = 0.0
            for i in range(length):
                if(i % 2 == 0):
                    sign = 1
                else:
                    sign = -1
                factor = self.m[0][i]
                if(factor != 0.0):
                    decomp = self._find_decomposed(i)
                    result += sign * factor * decomp.determinant()
                    if(self.verbose):
                        print(f"Column {i}: Adding {sign} * {factor} * {decomp.determinant()} to result, getting {result}")
        return result
    
    @property
    def is_jagged(self) -> bool:
        # Determines if a matrix is jagged (i.e. has rows of differing lengths)
        for i in range(1, len(self.m)):
            if(len(self.m[i]) != len(self.m[i-1])):
                return True
        return False
    
    @property
    def is_consistent(self) -> bool:
        # Determines if an (augmented) matrix is consistent - i.e. if it lacks 0=1 cases
        j = len(self.m) - 1
        if(self.m[j][-1] == 0):
            return True
        else: # if end value is nonzero, then the rest of the row must have a nonzero
            nonzero_value_present = False
            for i in range(len(self.m[0]) - 1):
                if(self.m[j][i] != 0):
                    nonzero_value_present = True
            return nonzero_value_present
        
    @property
    def is_square(self) -> bool:
        # Determines if a matrix is square (e.g. 2x2, 3x3, etc)
        return len(self.m) == len(self.m[0])
    
    def _swap(self, r1: int, r2: int) -> None:
        # Swaps two rows (generally used for Gauss-Jordan)
        if(r1 < len(self.m) and r2 < len(self.m)):
            (self.m[r1], self.m[r2]) = (self.m[r2], self.m[r1])
        if(self.verbose):
            print(f"Swaps rows {r1+1} and {r2+1}, new matrix:")
            print(self)

    def _scale(self, row: int, factor: float | int) -> None:
        # Scales a row by a given factor (generally used for Gauss-Jordan)
        if(row < len(self.m)):
            for i in range(len(self.m[row])):
                self.m[row][i] *= factor
        if(self.verbose):
            print(f"Scales row {row+1} by {factor}, new matrix:")
            print(self)
        if(self.ecl >= 2):
            self._round()

    def _eliminate(self, r1: int, r2: int, factor: float | int) -> None:
        # Eliminates a number from r1 by subtracting (r2[i] * factor) by itself
        if(r1 < len(self.m) and r2 < len(self.m)):
            for i in range(len(self.m[r1])):
                self.m[r1][i] -= self.m[r2][i] * factor
        if(self.verbose):
            print(f"Subtracts row {r2+1} * {factor} from row {r1+1}, new matrix:")
            print(self)
        if(self.ecl >= 2):
            self._round()

    def _round(self) -> None:
        # Accounts for floating-point error by eliminating any decimal values less than 10^-n, with n given by self.ecd
        for i in range(len(self.m)):
            for j in range(len(self.m[0])):
                rounded = round(self.m[i][j], self.ecd)
                if(rounded != self.m[i][j]):
                    self.m[i][j] = rounded

    def row_reduce(self, abort: bool = False) -> 'Matrix':
        # Performs Gauss-Jordan elimination on the matrix
        result = self.duplicate()
        if(abort and not self.is_consistent):
            return result
        # step 1 - get to echelon form (upper diagonal only)
        for i in range(len(result.m[0])):
            if(i < len(result.m)):
                # initial swap - ensures nonzero pivot
                if(result.m[i][i] == 0.0):
                    for j in range(i+1, len(result.m)):
                        if(result.m[j][i] != 0.0):
                            result._swap(i, j)
                # if pivot is still zero, then column is already cleared at and below the pivot
                if(result.m[i][i] != 0.0):
                    if(result.m[i][i] != 1.0):
                        result._scale(i, 1 / result.m[i][i])
                    for j in range(i+1, len(result.m)):
                        if(result.m[j][i] != 0):
                            result._eliminate(j, i, result.m[j][i])
                            if(abort and not self.is_consistent):
                                return result
        # matrix is now upper triangular
        # the range() below looks weird but it just traverses the list backwards
        for i in range(len(result.m)-1, -1, -1):
            if(i < len(result.m[0])):
                for j in range(i-1, -1, -1):
                    if(result.m[j][i] != 0):
                        result._eliminate(j, i, result.m[j][i])
                        if(abort and not self.is_consistent):
                            return result
        if(result.ecl >= 1):
            result._round()
        return result
    
    def duplicate(self) -> 'Matrix':
        # Returns a Matrix object with identical data (no shared memory addresses)
        new = Matrix()
        new.m = []
        for i in range(len(self.m)):
            new.m.append(self.m[i][:])
        new.verbose = self.verbose
        new.ecl = self.ecl
        new.ecd = self.ecd
        return new
    
    def transpose(self) -> 'Matrix':
        result = self._calloc(len(self.m[0]), len(self.m))
        for i in range(len(self.m)):
            for j in range(len(self.m[0])):
                result.m[j][i] = self.m[i][j]
        return result
    
    def inverse(self) -> 'Matrix':
        # Determines the inverse of a given square matrix
        if(len(self.m) == len(self.m[0])):
            compound = self.concat(self.identity(len(self.m)))
            compound = compound.row_reduce()
            left = compound._slice_columns(0, len(compound.m[0]) // 2)
            right = compound._slice_columns(len(compound.m[0]) // 2, len(compound.m))